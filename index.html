<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋（双人对战·计时·撤销）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
        }

        body {
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
        }

        .game-title {
            font-size: 28px;
            color: #333;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .game-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 480px;
            margin-bottom: 15px;
            padding: 10px 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .player-info {
            display: flex;
            gap: 20px;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chess-piece {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .black-piece {
            background-color: #000;
            border: 1px solid #666;
        }

        .white-piece {
            background-color: #fff;
            border: 1px solid #ccc;
        }

        .timer {
            font-size: 16px;
            color: #333;
            font-weight: 500;
        }

        .control-buttons {
            display: flex;
            gap: 12px;
        }

        button {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            background-color: #4285f4;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #3367d6;
        }

        button:disabled {
            background-color: #9aa0a6;
            cursor: not-allowed;
        }

        /* 修复核心：棋盘容器和网格样式（封闭网格） */
        .chess-board-container {
            position: relative;
            width: 480px;
            height: 480px;
            background-color: #e6c890;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            padding: 10px; /* 确保边缘线条完全显示，形成封闭网格 */
        }

        .chess-board {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .board-grid {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .horizontal-line {
            position: absolute;
            width: 100%;
            height: 1px;
            background-color: #333;
            left: 0;
        }

        .vertical-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background-color: #333;
            top: 0;
        }

        .chess-pieces {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .chess-piece-item {
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            transform: translate(-50%, -50%); /* 交点落子核心 */
            pointer-events: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10;
        }

        /* 黑棋、白棋样式补充 */
        .chess-piece-item.black-piece {
            background-color: #000;
            border: 1px solid #666;
        }

        .chess-piece-item.white-piece {
            background-color: #fff;
            border: 1px solid #ccc;
        }

        .win-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px 40px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .modal-content button {
            padding: 8px 24px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1 class="game-title">五子棋（双人对战）</h1>

    <div class="game-control">
        <div class="player-info">
            <div class="player">
                <div class="chess-piece black-piece"></div>
                <span>黑方:</span>
                <span id="black-timer" class="timer">00:00</span>
            </div>
            <div class="player">
                <div class="chess-piece white-piece"></div>
                <span>白方:</span>
                <span id="white-timer" class="timer">00:00</span>
            </div>
        </div>
        <div class="control-buttons">
            <!-- 新增：游戏开始按钮 -->
            <button id="start-btn">开始游戏</button>
            <button id="undo-btn" disabled>撤销一步</button>
            <button id="restart-btn" disabled>重新开始</button>
        </div>
    </div>

    <div class="chess-board-container">
        <div class="chess-board">
            <div class="board-grid" id="boardGrid"></div>
            <div class="chess-pieces" id="chessPieces"></div>
        </div>
    </div>

    <div class="win-modal" id="winModal">
        <div class="modal-content">
            <h2 id="winText">黑方获胜！</h2>
            <button id="confirmRestart">再来一局</button>
        </div>
    </div>

    <script>
        const BOARD_SIZE = 19;
        const GRID_SPACING = (460) / (BOARD_SIZE - 1); // 适配封闭网格容器尺寸

        // 新增：gameState添加isStarted（游戏是否已开始）状态
        let gameState = {
            currentPlayer: 'black',
            chessBoard: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
            moveHistory: [],
            blackTime: 0,
            whiteTime: 0,
            timerInterval: null,
            gameOver: false,
            isStarted: false // 新增：标记游戏是否已启动，默认未开始
        };

        // DOM 元素缓存（新增start-btn）
        const boardGrid = document.getElementById('boardGrid');
        const chessPieces = document.getElementById('chessPieces');
        const startBtn = document.getElementById('start-btn'); // 新增：开始按钮
        const undoBtn = document.getElementById('undo-btn');
        const restartBtn = document.getElementById('restart-btn');
        const blackTimer = document.getElementById('black-timer');
        const whiteTimer = document.getElementById('white-timer');
        const winModal = document.getElementById('winModal');
        const winText = document.getElementById('winText');
        const confirmRestart = document.getElementById('confirmRestart');

        // 初始化棋盘网格（封闭网格，无修改）
        function initBoardGrid() {
            // 生成横向线条（19条，从顶部到底部完全覆盖，形成封闭上沿、下沿）
            for (let y = 0; y < BOARD_SIZE; y++) {
                const horizontalLine = document.createElement('div');
                horizontalLine.className = 'horizontal-line';
                horizontalLine.style.top = `${y * GRID_SPACING}px`;
                boardGrid.appendChild(horizontalLine);
            }

            // 生成纵向线条（19条，从左到右完全覆盖，形成封闭左沿、右沿）
            for (let x = 0; x < BOARD_SIZE; x++) {
                const verticalLine = document.createElement('div');
                verticalLine.className = 'vertical-line';
                verticalLine.style.left = `${x * GRID_SPACING}px`;
                boardGrid.appendChild(verticalLine);
            }
        }

        // 初始化计时功能（无修改，仅在游戏开始后调用）
        function initTimer() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            gameState.timerInterval = setInterval(() => {
                if (gameState.gameOver) return;
                if (gameState.currentPlayer === 'black') {
                    gameState.blackTime++;
                    blackTimer.textContent = formatTime(gameState.blackTime);
                } else {
                    gameState.whiteTime++;
                    whiteTimer.textContent = formatTime(gameState.whiteTime);
                }
            }, 1000);
        }

        // 格式化时间（无修改）
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60).toString().padStart(2, '0');
            const sec = (seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }

        // 棋盘点击事件处理（新增：未开始游戏则直接返回，禁止落子）
        function handleBoardClick(e) {
            // 新增：两个限制条件：游戏未开始 或 游戏已结束，均禁止落子
            if (!gameState.isStarted || gameState.gameOver) return;

            const boardRect = boardGrid.getBoundingClientRect();
            const clickX = e.clientX - boardRect.left;
            const clickY = e.clientY - boardRect.top;
            const x = Math.round(clickX / GRID_SPACING);
            const y = Math.round(clickY / GRID_SPACING);

            // 边界判断 + 已有棋子判断（无修改）
            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
            if (gameState.chessBoard[y][x] !== null) return;

            // 落子（无修改）
            placeChessPiece(x, y);

            // 判断获胜（无修改）
            if (checkWin(x, y)) {
                endGame(gameState.currentPlayer);
                return;
            }

            // 切换玩家（无修改）
            switchPlayer();

            // 启用/禁用撤销按钮（无修改）
            undoBtn.disabled = gameState.moveHistory.length === 0;
        }

        // 落子操作（无修改）
        function placeChessPiece(x, y) {
            const currentPlayer = gameState.currentPlayer;
            gameState.chessBoard[y][x] = currentPlayer;
            gameState.moveHistory.push({ x, y, player: currentPlayer });

            const chessPiece = document.createElement('div');
            chessPiece.className = `chess-piece-item ${currentPlayer}-piece`;
            chessPiece.style.left = `${x * GRID_SPACING}px`;
            chessPiece.style.top = `${y * GRID_SPACING}px`;
            chessPiece.dataset.x = x;
            chessPiece.dataset.y = y;
            chessPieces.appendChild(chessPiece);
        }

        // 切换当前玩家（无修改）
        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 'black' ? 'white' : 'black';
        }

        // 五子连珠判断（无修改）
        function checkWin(x, y) {
            const currentPlayer = gameState.currentPlayer;
            const directions = [[1,0],[0,1],[1,1],[1,-1]]; // 横、竖、右斜、左斜
            for (const [dx, dy] of directions) {
                let count = 1;
                // 正向遍历
                for (let i = 1; i < 5; i++) {
                    const nx = x + dx * i;
                    const ny = y + dy * i;
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
                    if (gameState.chessBoard[ny][nx] !== currentPlayer) break;
                    count++;
                }
                // 反向遍历
                for (let i = 1; i < 5; i++) {
                    const nx = x - dx * i;
                    const ny = y - dy * i;
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
                    if (gameState.chessBoard[ny][nx] !== currentPlayer) break;
                    count++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        // 撤销一步操作（新增：未开始游戏则禁止撤销）
        function undoMove() {
            if (!gameState.isStarted || gameState.moveHistory.length === 0 || gameState.gameOver) return;

            const lastMove = gameState.moveHistory.pop();
            const { x, y, player } = lastMove;
            gameState.chessBoard[y][x] = null;

            const pieceToRemove = document.querySelector(`.chess-piece-item[data-x="${x}"][data-y="${y}"]`);
            if (pieceToRemove) chessPieces.removeChild(pieceToRemove);

            switchPlayer();
            undoBtn.disabled = gameState.moveHistory.length === 0;

            if (gameState.gameOver) {
                gameState.gameOver = false;
                winModal.style.display = 'none';
                initTimer();
            }
        }

        // 结束游戏（无修改）
        function endGame(winner) {
            gameState.gameOver = true;
            clearInterval(gameState.timerInterval);
            winText.textContent = `${winner === 'black' ? '黑方' : '白方'}获胜！`;
            winModal.style.display = 'flex';
            undoBtn.disabled = true;
        }

        // 新增：游戏开始函数（点击开始按钮触发）
        function startGame() {
            // 标记游戏已开始
            gameState.isStarted = true;

            // 启动计时
            initTimer();

            // 按钮状态更新：禁用开始按钮，启用重新开始按钮
            startBtn.disabled = true;
            restartBtn.disabled = false;

            // 提示（可选，可删除）
            console.log('游戏已开始，黑方先行！');
        }

        // 重新开始游戏（新增：重置isStarted状态，恢复按钮初始状态）
        function restartGame() {
            // 1. 重置游戏状态（包含新增的isStarted）
            gameState = {
                currentPlayer: 'black',
                chessBoard: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
                moveHistory: [],
                blackTime: 0,
                whiteTime: 0,
                timerInterval: null,
                gameOver: false,
                isStarted: false // 重置为未开始状态
            };

            // 2. 清空棋子DOM、重置计时显示
            chessPieces.innerHTML = '';
            blackTimer.textContent = '00:00';
            whiteTimer.textContent = '00:00';

            // 3. 重置按钮状态：启用开始按钮，禁用撤销、重新开始按钮
            startBtn.disabled = false;
            undoBtn.disabled = true;
            restartBtn.disabled = true;

            // 4. 隐藏胜利弹窗
            winModal.style.display = 'none';

            // 5. 清除原有定时器
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }

        // 绑定事件监听（新增：开始按钮点击事件）
        function bindEvents() {
            // 棋盘点击落子（无修改）
            boardGrid.addEventListener('click', handleBoardClick);

            // 新增：开始游戏按钮点击事件
            startBtn.addEventListener('click', startGame);

            // 撤销按钮（无修改，已添加未开始限制）
            undoBtn.addEventListener('click', undoMove);

            // 重新开始按钮（无修改）
            restartBtn.addEventListener('click', restartGame);
            confirmRestart.addEventListener('click', restartGame);
        }

        // 初始化游戏（无修改）
        function initGame() {
            initBoardGrid();
            bindEvents();
        }

        // 页面加载完成后启动游戏
        window.onload = initGame;
    </script>
</body>
</html>
